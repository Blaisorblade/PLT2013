# Exercise 2

## Presentation

## Maps, Filters and Folds

### [Functional Programming with Bananas](http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf)

For the two example functions `evens` and `odds` we saw in this session, we can
define two helper functions `isEven` and `isOdd` as follows.

```scala
def isEven = (n : Int) => n % 2 == 0
def isOdd  = (n : Int) => n % 2 == 1
```

Or we can simply use the anonymous functions appearing on the right hand sides
of the `=` in above defintions.

The three higher-order functions over `List[Int]` we have defined in this
session, `map`, `filter` and `fold` are given below:

```scala
def map(f : Int => Int, xs : List[Int]) : List[Int] = xs match {
  case Nil => Nil
  case x :: ys => f(x) :: map(f, ys)
}

def filter(p : Int => Boolean, xs : List[Int]) : List[Int] = xs match {
  case Nil => Nil
  case x :: ys => {
    if (p(x))
      x :: filter(p, ys)
    else
      filter(p, ys)
  }
}

def fold(f : (Int, Int) => Int, z : Int, xs : List[Int]) : Int = xs match {
  case Nil => z
  case x :: ys => f(x, fold(f, z, ys))
}
```

### Fold an Arithmetic Expression

## Parellel and Sequential Bindings

[`let`](http://docs.racket-lang.org/guide/let.html?q=parallel%20binding#%28part._.Parallel_.Binding__let%29) vs [`let*`](http://docs.racket-lang.org/guide/let.html?q=sequential%20binding&q=parallel%20binding#%28part._.Sequential_.Binding__let_%29) Ã  la Scheme/Racket

## Orders, Namespaces and Classes

### First-Order vs Higher-Order Functions

### Second-Class vs First-Class Functions

### Two Namespaces vs One Namespace

## Static vs Dynamic Scoping

